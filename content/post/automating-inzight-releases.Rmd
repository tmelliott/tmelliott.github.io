---
title: "Automating iNZight Releases"
# subtitle: ""
description: "After 5 years, I've finally put together a cloud-based, automated deployment system for iNZight using GitHub Actions"
images:
# - /post/image.jpg
date: 2020-09-17T11:29:44+12:00
draft: true
---

For several years now, the process by which iNZight gets deployed consisted of manually building the package binaries for Windows (and macOS, but that's now dead due to Apple making things excessively difficult) on my office desktop and uploading them to our self-hosted R package repository. Then I had to run the installer build script (which uses [NSIS]()) and upload the installer, and finally remember to update the version number on the website. This all took place over about a few days, with package release preparation taking place over a week and the deployment process happening over a Monday and/or Tuesday.

Of course, since it's impossible to test everything, there were always bugs cropping up in the first few days after a release (never deploy on a Friday)...

![](/post/nodeployfriday.jpg)

... so then of course I had to repeat the whole procedure. As a result, I tended not to get around to updating the installer as often (users could still update using iNZight's built-in updater).

For years, I've wanted to make it automated, particularly since GitHub Actions got going and it became a more plausible possibility. And now, finally, I have done just that! Here's an overview of what happens.

## Step 1: prepare package releases

For a couple of years now, I've been using the [`git flow`]() branch management framework, which effectively uses `master` for the stable release, `develop` for the "nightly build" or unstable release, plus **feature** branches of the form `feature/my-cool-new-feature` (based on `develop`), **bugfix** brances (`bugfix/a-weird-bug`, also based on `develop`), and **release** brances (`release/1.0.2`, also based on `develop` but merged into `master`). Occasionally there's also a **hotfix** based on the `master` branch, which fixes a critial bug in the release version.

After merging in any `feature/` and `bugfix/` branches that we want in the next release, I create a new release branch (let's assume the new version is 1.2.3):
```bash
git flow release start 1.2.3
# which is the equivalent of `git checkout dev && git checkout -b release/1.2.3`
```
On this new branch, you do things like bump the version in the `DESCRIPTION` file, update the `NEWS.md` file, plus check things work and fix any final bugs. Once complete, you can either finialise the release using `git flow release finish`, which will automatically merge the release into *both master and develop, **or** you head over to GitHub and create two pull requests: `release/1.2.3 -> master` and `release/1.2.3 -> develop`. Let all your continuous integration (I'm using GitHub Actions for iNZight) pass and then merge those PRs! The last step is to tag the new release and clean up:
```bash
git checkout master
git fetch -p # the release branch is now deleted
git merge origin master
git tag 1.2.3
git push --tags
git checkout dev && git merge origin/dev && git branch -d release/1.2.3
```

Now repeat that for all package releases (iNZight consists of 11 packages, so this takes the better part of a day if we're doing a big update, but it's pretty straightforward).


## Step 2: build binaries and installer

Previously, this was all done manually. But from there, it's completely automated with one single trigger by updating the `iNZightVIT/builder` repository.

### git modules
